from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import maya_pipeline as mp

# Python
from builtins import int

# Maya
from maya.app.general.mayaMixin import MayaQWidgetDockableMixin
import pymel.core as pm
from maya import OpenMayaUI as omui

# PySide2
from PySide2.QtWidgets import QWidget, QMainWindow
from PySide2.QtCore import Signal
from shiboken2 import wrapInstance

# Internal
import maya_pipeline as mp

__all__ = ["DockableMainWindow", "create_dockable_main_win", "create_workspace_control",
           "create_workspace_control_with_dockable_main_win", "delete_workspace_control",
           "delete_workspace_control_widgets", "get_dockable_main_win_child", "get_dockable_win_name",
           "get_workspace_control_name", "restore_workspace_control", "workspace_control_exists"]


class DockableMainWindow(MayaQWidgetDockableMixin, QWidget):
    def __init__(self, title: str, ui_main_window: QMainWindow, parent=None):
        """
        :param ui_main_window: reference to the Ui_MainWindow class generated by Qt Designer
        """
        mp.debug_log("DockableMainWindow > __init__...")
        super(DockableMainWindow, self).__init__(parent=parent)
        self.main_window = QMainWindow(parent=None)
        self.ui_main_window = ui_main_window
        self.ui_main_window.setupUi(self.main_window)
        self.title = title

    on_dock_closed = Signal()

    def dockCloseEventTriggered(self):
        self.on_dock_closed.emit()


def create_workspace_control_with_dockable_main_win(title: str,
                                                    ui_main_window: QMainWindow,
                                                    mode: mp.UI_Creation_Mode) -> DockableMainWindow:
    """
    :param title: window title
    :param ui_main_window: QMainWindow object from Qt Designer Python code (e.g. class Ui_MainWindow(object):)
    :param mode:
    DEFAULT mode is what users should use. \n
    RESTORE_FROM_MAYA_PREFS mode is not meant to be called directly, and is only meant to be called
    from the uiScript command which saves the command in Maya prefs so when Maya restarts it can restore the control.
    RECREATE mode is for devs that have changed code and need to destroy and recreate the window. \n
    """
    dockable_main_win: DockableMainWindow = None
    workspace_control_name = get_workspace_control_name(title)

    if mode is mp.UI_Creation_Mode.DEFAULT:
        if workspace_control_exists(workspace_control_name):
            restore_workspace_control(workspace_control_name)

            workspace_control_widget: QWidget = None
            maya_main_window_ptr = omui.MQtUtil.mainWindow()
            maya_main_window = wrapInstance(int(maya_main_window_ptr), QWidget)

            # Have to keep this code in this location or the widget may go out of scope and get deleted.
            for child_widget in maya_main_window.findChildren(QWidget):
                if child_widget.objectName() == workspace_control_name:
                    workspace_control_widget = child_widget  # Found workspace control widget
                    break

            dockable_main_win = get_dockable_main_win_child(workspace_control_widget)
        else:
            mp.debug_log(f"Workspace Control: {workspace_control_name} doesn't exist. Creating it from scratch...")
            dockable_main_win = create_dockable_main_win(title=title, ui_main_window=ui_main_window)
            create_workspace_control(title, dockable_main_win)
    elif mode is mp.UI_Creation_Mode.RESTORE_FROM_MAYA_PREFS:
        mp.debug_log("Restoring from Maya prefs...")
        # Unlike the modes above, we don't destroy the existing control because it's stored in Maya General.json
        # and will throw an Access Violation.
        dockable_main_win = create_dockable_main_win(title=title, ui_main_window=ui_main_window)
        # Get the current maya control that the mixin widget should parent to
        restored_control = omui.MQtUtil.getCurrentParent()
        # Find the widget created above as a maya control (aka a maya class)
        mixin_ptr = omui.MQtUtil.findControl(dockable_main_win.objectName())
        # Add custom mixin widget to the workspace control
        omui.MQtUtil.addWidgetToMayaLayout(int(mixin_ptr), int(restored_control))
    elif mode is mp.UI_Creation_Mode.RECREATE:
        mp.debug_log("Recreating window...")
        # Force the workspace control to be recreated during development
        if workspace_control_exists(workspace_control_name):
            mp.debug_log(f"Deleting workspace control: {workspace_control_name}")
            delete_workspace_control_widgets(workspace_control_name)
            delete_workspace_control(workspace_control_name)

        dockable_main_win = create_dockable_main_win(title=title, ui_main_window=ui_main_window)
        create_workspace_control(title, dockable_main_win)
    else:
        mp.debug_error(f"mode={mode} unsupported.", print_to_script_editor=True)

    if dockable_main_win is None:
        mp.debug_error("dockable_main_win == None", print_to_script_editor=True)

    mp.debug_log("Finished running dockable_main_win_script()")

    return dockable_main_win


def get_dockable_win_name(title: str) -> str:
    return title.replace(" ", "")  # remove spaces


def create_dockable_main_win(title: str, ui_main_window: QMainWindow) -> DockableMainWindow:
    mp.debug_log(f"create_dockable_main_win(title={title})")
    dockable_main_win_name = get_dockable_win_name(title)
    dockable_main_win = DockableMainWindow(title=title, ui_main_window=ui_main_window)
    dockable_main_win.setObjectName(dockable_main_win_name)

    return dockable_main_win


def get_dockable_main_win_child(parent: QWidget) -> DockableMainWindow:
    mp.debug_log(f"Looking for dockable_main_win inside {parent}...")
    dockable_main_win: DockableMainWindow = None

    for child_widget in parent.findChildren(QWidget):
        if isinstance(child_widget, DockableMainWindow):
            dockable_main_win = child_widget
            mp.debug_log(f"Found DockableMainWindow: {dockable_main_win.objectName()}")
            break

    if dockable_main_win is None:
        mp.debug_error(f"Didn't find DockableMainWindow in parent: {parent}.", print_to_script_editor=True)

    return dockable_main_win


def get_workspace_control_name(title: str) -> str:
    return get_dockable_win_name(title) + "WorkspaceControl"


def create_workspace_control(title: str, dockable_main_win: DockableMainWindow):
    mp.debug_log("create_workspace_control...")
    # If the window still exists in the Maya editor when Maya is closed,
    # the command in ui_script will be stored in Maya's General.json.
    # When Maya restarts, the command will be run to restore the window.
    ui_script = f"import maya_pipeline as mp\nmp.main_app.main_app.open('{title}', " \
                f"mp.UI_Creation_Mode.RESTORE_FROM_MAYA_PREFS)"
    mp.debug_log("showing workspace control...")
    # The show method creates a workspace control and appends "WorkspaceControl" to the dockable_main_win name
    dockable_main_win.show(dockable=True, uiScript=ui_script)


def workspace_control_exists(name: str) -> bool:
    exists = bool(pm.workspaceControl(name, query=True, exists=True))
    if exists:
        mp.debug_log(f"Workspace Control: {name} exists")
    else:
        mp.debug_log(f"Workspace Control: {name} doesn't exist")

    return exists

def restore_workspace_control(name: str):
    if pm.workspaceControl(name, query=True, visible=True):
        mp.debug_log(f"Workspace control {name} is visible, restoring it.")
        pm.workspaceControl(name, edit=True, restore=True)
    else:
        mp.debug_log(f"Workspace control {name} is invisible, making it visible.")
        pm.workspaceControl(name, edit=True, visible=True)


# Sometimes you can't delete or completely delete the workspace control because the widgets are still active in memory,
# so we delete the widgets prior to deleting the control.
def delete_workspace_control_widgets(workspace_control_name: str):
    if workspace_control_exists(workspace_control_name):
        mp.debug_log(f"Deleting widgets inside Workspace Control {workspace_control_name}.")
        mp.debug_log(f"Temp restoring {workspace_control_name} so we can delete the widgets.")
        restore_workspace_control(workspace_control_name)

        workspace_control_widget: QWidget = None
        maya_main_window_ptr = omui.MQtUtil.mainWindow()
        maya_main_window = wrapInstance(int(maya_main_window_ptr), QWidget)
        dockable_main_win: DockableMainWindow = None

        # Have to keep this code in this location or the widget may go out of scope and get deleted.
        for child_widget in maya_main_window.findChildren(QWidget):
            if child_widget.objectName() == workspace_control_name:
                workspace_control_widget = child_widget
                mp.debug_log(f"Found workspace_control: {workspace_control_widget.objectName()}")
                break

        if workspace_control_widget is not None:
            dockable_main_win = get_dockable_main_win_child(workspace_control_widget)
        else:
            mp.debug_warning("workspace_control_widget is None. Can't proceed with deleting child widgets.",
                             print_to_script_editor=True)

        if dockable_main_win is not None:
            mp.debug_log(f"Marking children of {dockable_main_win} to deleteLater.")
            # Iterate over the children of the widget
            for child in dockable_main_win.children():
                # Schedule the child to be deleted
                mp.debug_log(f"- {child}.deleteLater()")
                child.deleteLater()
    else:
        mp.debug_warning(
            f"Can't delete widgets in workspace control {workspace_control_name} because it doesn't exist.",
            print_to_script_editor=True)


def delete_workspace_control(workspace_control_name: str):
    if workspace_control_exists(workspace_control_name):
        mp.debug_log(f"Deleting Workspace Control {workspace_control_name}.")
        pm.workspaceControl(workspace_control_name, edit=True, close=True)
        pm.deleteUI(workspace_control_name)
    else:
        mp.debug_warning(f"Can't delete workspace control {workspace_control_name} because it doesn't exist.",
                         print_to_script_editor=True)
